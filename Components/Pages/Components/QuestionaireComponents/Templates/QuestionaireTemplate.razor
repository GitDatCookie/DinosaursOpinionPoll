@page "/test"
@using AI_Project.Models.OrderModels
@using MudBlazor
@inject IComponentFactory ComponentFactory

<MudDropContainer T="(QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType)"
@bind-Items="currentPageItems"
ItemsSelector="@( (item, zone) => item.ViewModel.Order.DropZoneIdentifier == zone )"
ItemDropped="ItemDropped"
Class="d-flex flex-grow-1"
@ref="MudDropContainerRef">
    <ChildContent>
        <MudContainer Class="pa-4" Style="flex: 1;">
            <MudStack Spacing="2" AlignItems="AlignItems.Center">
                <MudPagination Color="Color.Primary"
                Count="@Questionaire.PageList.Count"
                @bind-Selected="SelectedPage" />
                <MudText Typo="Typo.subtitle1">Selected page: @_selected</MudText>
                <MudStack Spacing="2">
                    <MudButton Variant="Variant.Filled"
                    Color="Color.Primary"
                    OnClick="@AddPage">
                        Add Page
                    </MudButton>
                    @if (Questionaire.PageList.Count > 1)
                    {
                        <MudButton Variant="Variant.Filled"
                        Color="Color.Error"
                        OnClick="@DeleteCurrentPage">
                            Delete Page
                        </MudButton>
                    }
                </MudStack>
            </MudStack>

            <MudPaper Class="ma-4 flex-grow-1">
                <MudList T="string" Class="d-flex flex-column mud-height-full">
                    <MudListSubheader>@($"Destination Zone (Page {_selected})")</MudListSubheader>
                    <MudDropZone T="(QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType)"
                    Identifier="@($"DestinationZone_{_selected}")"
                    AllowReorder="true"
                    Class="flex-grow-1"
                    Style="min-height:50px">
                    </MudDropZone>
                </MudList>
            </MudPaper>
        </MudContainer>
        <MudDrawer Elevation="2"
        Open="true"
        Anchor="Anchor.Right"
        ClipMode="DrawerClipMode.Always"
        Width="300px"
        Style="flex-shrink: 0;">
            <MudList T="string">
                <DrawerBaseComponent OnItemSelected="OnItemHandled" />
            </MudList>
        </MudDrawer>
    </ChildContent>

    <ItemRenderer>
        <RandomGroupTemplate RandomGroups="Questionaire.RandomQuestionaireComponentGroups" RandomGroupType="ERandomGroupType.RandomQuestionairePageComponentGroup" RandomGroupsChanged="HandleRandomGroupsChanged"/>
        <DynamicComponentComponent ItemType="@context.ItemType"
        QuestionType="@context.QuestionType"
        ViewModel="@context.ViewModel"
        IsItemEditable="false" />
    </ItemRenderer>
</MudDropContainer>

@code {
    [Parameter]
    public QuestionaireViewModel Questionaire { get; set; } = new();

    public Guid PageRandomGroupId { get; set; }

    // Using the tuple type (as you confirmed this is not the culprit)
    private List<(QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType)> currentPageItems = new();

    private int _selected = 1;
    private int SelectedPage
    {
        get => _selected;
        set
        {
            if (_selected != value)
            {
                _selected = value;
                RefreshCurrentItems();
                // When switching pages, simply update the UI without reassigning the list.
                RefreshUI(forceContainerRefresh: false);
            }
        }
    }

    protected override void OnInitialized()
    {
        // Initialize with one page.
        Questionaire.PageList = new List<QuestionairePageViewModel>
        {
            new QuestionairePageViewModel
            {
                OrderID = 1,
                Items = new List<(QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType)>()
            }
        };
        Questionaire.RandomQuestionaireComponentGroups = new();

        // Set the item reference to the first page’s list.
        currentPageItems = Questionaire.PageList[0].Items;
    }


    private void HandleRandomGroupsChanged(List<RandomGroupViewModel> updatedGroups)
    {
        Questionaire.RandomQuestionaireComponentGroups = updatedGroups;
        StateHasChanged(); // Force UI refresh
    }

    private MudDropContainer<(QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType)> MudDropContainerRef { get; set; }

    // When switching pages, update the pointer to the stored list.
    private void RefreshCurrentItems()
    {
        if (Questionaire.PageList.Count >= _selected)
        {
            currentPageItems = Questionaire.PageList[_selected - 1].Items;
        }
        else
        {
            currentPageItems = new List<(QuestionaireComponentViewModelBase, EItemType, EQuestionType)>();
        }
    }

    /// <summary>
    /// Refreshes the UI. Use forceContainerRefresh true only when necessary (e.g. adding items).
    /// Here we avoid reassigning (cloning) the list reference so that the binding remains intact.
    /// </summary>
    /// <param name="forceContainerRefresh">When true, forces a full container refresh.</param>
    private void RefreshUI(bool forceContainerRefresh = false)
    {
        StateHasChanged();
        if (forceContainerRefresh && MudDropContainerRef is not null)
        {
            MudDropContainerRef.Refresh();
        }
    }

    private void AddPage()
    {
        Questionaire.PageList.Add(new QuestionairePageViewModel
            {
                OrderID = Questionaire.PageList.Count + 1,
                Items = new List<(QuestionaireComponentViewModelBase, EItemType, EQuestionType)>()
            });
        _selected = Questionaire.PageList.Count;
        RefreshCurrentItems();
        // For adding a new page, a full refresh is acceptable.
        RefreshUI(forceContainerRefresh: true);
    }

    private void DeleteCurrentPage()
    {
        if (Questionaire.PageList.Count > 1)
        {
            Questionaire.PageList.RemoveAt(_selected - 1);
            if (_selected > Questionaire.PageList.Count)
            {
                _selected = Questionaire.PageList.Count;
            }
            RefreshCurrentItems();
            RefreshUI(forceContainerRefresh: true);
        }
    }

    // When an item is selected from the drawer, create it and add it if it’s not a duplicate.
    private void OnItemHandled((QuestionaireComponentViewModelBase ViewModel, EItemType ItemType, EQuestionType QuestionType) selectedItem)
    {
        var newComponent = ComponentFactory.CreateComponent(selectedItem.ViewModel);
        newComponent.Order = new()
            {
                DropZoneIdentifier = $"DestinationZone_{_selected}"
            };

        if (!currentPageItems.Any(x => x.ViewModel.Id == selectedItem.ViewModel.Id))
        {
            currentPageItems.Add((newComponent, selectedItem.ItemType, selectedItem.QuestionType));
            // For new items, force a container refresh.
            RefreshUI(forceContainerRefresh: true);
        }
    }

    // On drag–drop reordering, update the UI without forcing container refresh.
    public void ItemDropped()
    {
        RefreshUI(forceContainerRefresh: false);
    }

    public void SaveQuestionaire()
    {
        // Your save logic here.
    }
}
